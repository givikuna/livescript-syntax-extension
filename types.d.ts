type PipeFunction<T, U> = (x: T) => U;

declare module "lsse" {
    export function mapcar<T, T2>(f: (x: T2) => T2, xs: Array<T>): Array<T2>
    export function str(s: any): string;
    export function int(n: number | string): number;
    export function random(minVal: number, maxVal: number): number;
    export function lower(s: string): string;
    export function upper(s: string): string;
    export function inc(n: number): number;
    export function dec(n: number): number;
    export function supertrim(s: string): string;
    export function freq<T>(k: T, xs: T[]): number;
    export function len<T>(xs: string | Array<T>): number;
    export function enumerate<T>(xs: Array<T>): Map<number, T>;
    export function member<T>(k: T, xs: Array<T>): boolean;
    export function map2<T, T2, T3>(f: (x: T, y: T2) => T3, xs: Array<T>, ys: Array<T>): Array<T3>;
    export function listRef<T>(i: number, xs: Array<T>): T;
    export function hashRef<T>(k: string, xs: {[key: string]: T}): T;
    export function buildList<T>(n: number, f: (n: number) => T): Array<ReturnType<typeof f>>;
    export function title(s: string): string;
    export function uniq(xs: Array<any>): Array<any>;
    export function memoize(f: Function): typeof f;
    export function sorted<T>(xs: Array<T>): Array<T>;
    export function noop(): void;
    export function id<T>(it: T): T;
    export function before(beforeFunc: Function, func: Function): Function;
    export function after(func: Function, afterFunc: Function): Function;
    export function throttle(func: Function, delay: number): Function;
    export function debounce(func: Function, delay: number): Function;
    export function lazy(f: Function): Function;
    export function listTo(x: number, y: number): Array<number>;
    export function listFrom(x: number, y: number): Array<number>;
    export function bool(it: any): boolean;
    export function pipe<T, U>(x: T, ...fs: Array<PipeFunction<any, any>>): U;
    export function cond<T>(...conditions: Array<[boolean, any] | [string, any]>): T;
    export function expt(n: number, power: number): number;
    export function replaceAll(x1: string, x2: string, xs: string): string;
    export function removeAll(x: string, xs: string): string;
    export function stringAppend(s1: string, s2: string): string;
    export function iter<T>(xs: Array<T>): Iterator<T>;
    export const say: typeof console.log;
    export function indexOf<T>(x: T, xs: T[]): number;
    export function isNumeric(xs: string): boolean;
    export function csc(n: number): number;
    export function sec(n: number): number;
    export function cot(n: number): number;
    export function arcsin(n: number): number;
    export function arccos(n: number): number;
    export function arctan(n: number): number;
    export const exmp1: typeof Math.expm1;
    export function replace(x1: string, x2: string, xs: string): string;
    export function trimStart(s: string): string;
    export function trimEnd(s: string): string;
    export function input(s: string): string;
    export function charcode(s: string): string;
    export function makeHash(xs: [string, any]): {[key: string]: any};
    export function fold0<T>(f: (x: T, y: T) => T, xs: Array<T>): T;
    export function foldl0<T>(f: (x: T, y: T) => T, xs: T[]): T;
    export function fodlr0<T>(f: (x: T, y: T) => T, xs: Array<T>): T;
    export function transpose<T>(xs: T[]): T[];
    export function chunk<T>(arr: T[], size: number): T[][];
    export type sleepOption = 'milliseconds' | 'seconds' | 'hours' | 'days';
    export function sleep(amount: number, type?: sleepOption): void;
    export function lambda<T>(f: (...args: any) => T): typeof f;
    export const fn: typeof lambda;
}
